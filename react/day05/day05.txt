

CSR (Client Side Rendering), SPA/MPA(가능)
웹 페지 랜더링에 필요한 리소스를 다운로드 받고, 클라이언트(브라우저가) 화면을
그리는 모든 행위를 하는 것

장점
- 초기 랜더링 속도는 느리지만, 이후의 페이지 이동 랜더링 속도는 빠름
- 서버 비용 절약

단점 
- 페이지 초기 랜더링 속도가 느림. 사용자가 화면을 늦게 봄
- 과정에 대해서 클라이언트가 실행하기 때문에 검색엔진에 노출이 되지 않음
(빈화면 상태에서 브라우저가 화면을 그려야만 검색엔진에 노출)
빈화면x -> 검색엔진이 수집할 수 있는 정보가 한정적, SEO(seach engine optimization)에 불리 



----------------------------

SSR (Server Side Rendering), SPA/MPA(가능) (필요한 리소스만 다운로드)
웹 페이지 구상에 필요한 리소스를 준비한다. 브라우저는 받아서 화면을 그리는 것만 하는 것

(장점)

SEO (검색엔진최적화) - 블로그, 쇼핑몰, 커뮤니티
초기랜더링속도(하나의 페이지 완벽히 보이는 것)

(단점) 
이후의 페이지 랜더링 속도가 느립니다
학습 곡선 (최소 1~2달)
서버(컴퓨터) 비용


----------------------------

useMemo

메모한다. 기억 하기 위해서
리랜더링 되면 연산도 다시 진행하는지

const Component = () => {
    const a = 2+3; // 리랜더링 -> 2+3을 다시 할 필요가 없다

    return <>{a}</> // 5
}

리랜더링 시에 결과 값이 같다면 재연산을 하지 않기 위해서
값을 기억하는 훅 함수

const Componetn = () => {
    const [count, setCount] = useState(0)
    const a= 2 + count

    return 
    <>
        {a}
        <button onClick=()=>setCount((prev)=>prev+1)>+</button> \
    </>
}

useMemo를 사용하면 재연산을 하고 싶을 때는 의존성 배열을 활용하여 재연산 가능

=> 리랜딩 시 연산이 필요하지 않은 경우 값을 메모했다가 재활용
=> 기억한다는 것은 코스트가 드는 행위 -> 남발하면 안됨 => 복잡한 연산인 경우에만 memo

메모아이제이션


useCallback

  const Component = () => {
    function addNumber(num1,num2) {
        return num1+num2
    }

    const a = addNumber(1,2)

    return {<>a</>}
  }

리랜더링 시 함수가 재선언되지 않도록 함수 값을 기억하고 있는 것
의존성 배열에 따라 값을 다시 선언할 수 있습니다.

callbackfunction으로 넘어가는 경우 많이 활용
React.memo와 활용할 대 많이 활용
함수 정의 내용이 복잡한 경우

=> memo는 연산에 대한 결과를 캐싱
=> callback은 연산을 하는 함수를 저장(기억, 캐싱)



React.memeo
  
  PureComponent -> 부모 요소나 다른 요소가 리랜더링되어도 리래넏링을 건너뛰는 컴포넌트
  실무에서 사용하는 케이스 엄청 많지는 않아요

----------------------------

CustomHook

Context

----------------------------


flex grid 공부

리액트 훅을 활용한 마이크로 상태 관리 

이펙티브 타입스크립트

우아한 타입스크립트 with 리액트


모던 리액트 deep dive


React.memo
  PureComponent -> 부모 요소나 다른 요소가 리랜더링 되어도 리랜더링을 건너뛰는 컴포넌트
  실무에서 사용하는 케이스 엄청 많지는 않음

  부모 컴포넌트가 리랜더링 되면 자식 컴포넌트도 리랜더링
  상태는 반드시 필요한 컴포넌트에 위치

  